//write data to flash during program execution 
//before running this file must change 'code/ const' to ram
//regions available to store memory on kl25z
volatile ir_command device_1[45] __attribute__((at(0x09000)));
volatile ir_command device_2[45] __attribute__((at(0x0A000)));
volatile ir_command device_3[45] __attribute__((at(0x0B000)));
volatile ir_command device_4[45] __attribute__((at(0x0C000)));
volatile char frame_buff_store[176][33] __attribute__((at(0x0D000)));
volatile int page __attribute__((at(0x0C500)));
volatile int device __attribute__((at(0x0C504)));
volatile int signed tv_locat[6] __attribute__((at(0x0C800)));
volatile int signed dvd_locat[6] __attribute__((at(0x0CF00)));

int flash_EraseSector(long int sector) //erase area you want to save to memory
{
    int temp1,temp2,temp3;

    //Dividing the sector address into the 3 bytes before starting to fill the FCCOB
  //registers reduces the risk of the operation being corrupted:

            temp1 = (sector << 8);
            temp1 = temp1 >> 24;
    
            temp2 = (sector << 16);
            temp2 = temp2 >> 24;
    
            temp3 = (sector << 24);
            temp3 = temp3 >> 24;
    
    //Wait until the command complete instruction is cleared indicate the FCCOB registers
  //are available:

            while(((FTFA->FSTAT)&(1UL << 7))==0x00);
    
    //Clear any previous errors from the last operation:
    
            if(!((FTFA->FSTAT)==0x80))
                    {FTFA->FSTAT = 0x30;}

            FTFA->FCCOB0 = 0x09;     // 0x09 is the instruction code for erase
            FTFA->FCCOB1 = temp1;    // Load the segment address into registers
            FTFA->FCCOB2 = temp2;
            FTFA->FCCOB3 = temp3;

            FTFA->FSTAT = 0x80;         // Writing a 1 to bit 7 of the FSTAT register launches 

            // Wait for command completion:

            while(((FTFA->FSTAT)&(1UL << 7))==0x00);

    return 1;

}
//Write a page and device to flash memory.
void flash_memory_tv_loc(signed int ax,signed int ay,signed int az,signed int hx,signed int hy,signed int hz)
{
    int j;
    for(j=0;j<10000;j++); //delay
    flash_EraseSector((int)&tv_locat);
    for(j=0;j<100;j++);
    flash_writeLongWord((int)&tv_locat[0],ax);
    flash_writeLongWord((int)&tv_locat[1],ay);
    flash_writeLongWord((int)&tv_locat[2],az);
    flash_writeLongWord((int)&tv_locat[3],hx);
    flash_writeLongWord((int)&tv_locat[4],hy);
    flash_writeLongWord((int)&tv_locat[5],hz);

}
//Write a long word to an erased flash block
int flash_writeLongWord(long int locat,long int value)
{
        int temp1,temp2,temp3,temp4,temp5,temp6,temp7;

            temp1 = (locat << 8);
            temp1 = temp1 >> 24;
            temp2 = (locat << 16);
            temp2 = temp2 >> 24;
            temp3 = (locat << 24);
            temp3 = temp3 >> 24;
            temp4 = value >> 24;
            temp5 = (value << 8);
            temp5 = temp5 >> 24;
            temp6 = (value << 16);
            temp6 = temp6 >> 24;
            temp7 = (value << 24);
            temp7 = temp7 >> 24;


            while(((FTFA->FSTAT)&(1UL << 7))==0x00);    

            if(!((FTFA->FSTAT)==0x80))
                    {FTFA->FSTAT = 0x30;}

            FTFA->FCCOB0 = 0x06;    //0x06 is instruction code for write long word.

            FTFA->FCCOB1 = temp1;
            FTFA->FCCOB2 = temp2;
            FTFA->FCCOB3 = temp3;
            FTFA->FCCOB4 = temp4;
            FTFA->FCCOB5 = temp5;
            FTFA->FCCOB6 = temp6;
            FTFA->FCCOB7 = temp7;

            FTFA->FSTAT = 0x80;

            while(((FTFA->FSTAT)&(1UL << 7))==0x00);

        return 1;
}
